var documenterSearchIndex = {"docs":
[{"location":"Internals/","page":"Internals","title":"Internals","text":"CurrentModule = WebAssemblyText","category":"page"},{"location":"Internals/#WebAssemblyText","page":"Internals","title":"WebAssemblyText","text":"","category":"section"},{"location":"Internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"Internals/","page":"Internals","title":"Internals","text":"Modules = [WebAssemblyText]","category":"page"},{"location":"Internals/#WebAssemblyText.builtinfuncs","page":"Internals","title":"WebAssemblyText.builtinfuncs","text":"builtinfuncs: a dict with handwritten .wat of some julia builtins.\n\nDetails:\n\ncant use types such as Bool or Nothing or multiple return values  wasm does comparison as ints with i32.const 0 meaning false so :(iterate) have to return 0 instead of false when iterator is empty, which is an issue when iterating across zero.\n\n\n\n\n\n","category":"constant"},{"location":"Internals/#WebAssemblyText.argtypes!-Tuple{Core.CodeInfo,Dict,Dict,Any}","page":"Internals","title":"WebAssemblyText.argtypes!","text":"argtypes!(ci::CodeInfo, argtypes::Dict, funcs::Dict, items::Array)\n\nInfer argtypes and update argtypes if items[1] is in funcs.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.blockinfo-Tuple{Array}","page":"Internals","title":"WebAssemblyText.blockinfo","text":"blockinfo(ssa::Array)\n\nInfer a tree of WebAssembly blocks from ssa and return a BlockInfo struct containing\n\na goto dict\na list of which blocks each ssa index is a child of.\n\nDetails\n\nWebAssembly control instructions (mainly) consist of\n\nblocks: block, loop\nbranching: br, br_if, return\n\nNotes concerning WebAssembly control instructions:\n\nWe do not have Phi nodes (a block can only have one parent)\nWe do not have gotos/jumps. We can only branch backwards/up the block tree.\nHowever, branching to a block continues at end of that block, which effectively is a forward jump (aka break)\nSpecial case: branching to a loop block continues at start of that block (aka continue)\nbranching is specified in terms of number of levels up (br 0 goes to current block, br 1 goes to parent block and so on. return is essentialy sugar for br MAX)\n\nSo the strategy is to infer a blocktree from arbitrary gotos, insert blocks and translate gotos to branching in terms of levels up the tree.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.blockparse-Tuple{String}","page":"Internals","title":"WebAssemblyText.blockparse","text":"blockparse(str::String)\n\nInitial Meta.parse() on entire input. return funcs and initialize Dicts of argtypes and imports.\n\nDetails:\n\nfuncs: a dict with function,expression as key,values\nargtypes: a dict with with function,argtypes as key,values\nimports: a dict with with function,importstring as key,values\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.codeinfo-Tuple{Any,Array}","page":"Internals","title":"WebAssemblyText.codeinfo","text":"codeinfo(func::Symbol, argtypes::Array)\n\nEssentially code_typed() with optimize=false\n\nDetails:\n\nNot optimizing complicates type inference, but ultimately simplifies translation becuase the returned CodeInfo is much cleaner.\n\nAlso, we have to modifiy CodeInfo by\n\nmaking sure sure slotnames contain names\nmaking sure slottypes and ssavaluetypes contain types\n\nthis has mostly to do with iterator variables\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.declaration-NTuple{4,Any}","page":"Internals","title":"WebAssemblyText.declaration","text":"declaration(cinfo, func, argtypes, Rtype)\n\nGet a wat string with function declaration.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.getbuiltins-Tuple{Array}","page":"Internals","title":"WebAssemblyText.getbuiltins","text":"getbuiltins(ssa::Array)\n\nGet an array of strings with any used builtin .wat functions as specified by the dict builtinfuncs.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.getimports-Tuple{Dict}","page":"Internals","title":"WebAssemblyText.getimports","text":"getimports(imports::Dict)\n\nGet a .wat string with any used functions that are not builtins or userdefined.\n\nDetails\n\na few basic are builtin to wasm. these can be translated.\nother basic functions are bultin to JavaScripts global Math object, these can be imported\nmany more are builtin to julia... so they need to be implemented either in .jl, .wat or .js\ngive warning if the function cant be imported from js Math.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.itemtype-Tuple{Core.CodeInfo,Any}","page":"Internals","title":"WebAssemblyText.itemtype","text":"itemtype(ci::CodeInfo, item)\n\nGet a concrete type, specialized on item type.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.jl2wat-Tuple{AbstractString}","page":"Internals","title":"WebAssemblyText.jl2wat","text":"jl2wat(path::AbstractString)\n\nConvert contents of a julia source code file to WebAssembly text.\n\nExamples\n\njulia> using WebAssemblyText\njulia> wat = jl2wat(\"example.jl\")\njulia> println(wat)\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.jlstring2wat-Tuple{AbstractString}","page":"Internals","title":"WebAssemblyText.jlstring2wat","text":"jlstring2wat(str::AbstractString)\n\nConvert a string of julia source code to WebAssembly text.\n\nExamples\n\njulia> using WebAssemblyText\njulia> str=\"\nhello(x) = 2.0*x\nhello(1.0)\n\";\njulia> wat = jlstring2wat(str);\njulia> println(wat)\n\n(module \n\n(func $hello (export \"hello\") (param $x f32) (result f32)\n( return ( f32.mul (f32.const 2.0) (local.get $x) ) ))\n)\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.jsimportentry-Tuple{Any,Any}","page":"Internals","title":"WebAssemblyText.jsimportentry","text":"jsimportentry(func, argtypes)\n\nGet a string of possible javascript Math module import, assuming it exists in the Math module.\n\nDetails\n\nfrom a func such as sin, return a string like \"sin: (x) => Math.sin(x)\"\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.process-NTuple{4,Any}","page":"Internals","title":"WebAssemblyText.process","text":"process(func, funcs, argtypes)\n\nGet a string with a self contained (func ) expression in .wat format\n\nDetails\n\nThe main steps of translating a single function\n\ntype infer func given argtypes[func]\nstructure ssa\nupdate argtypes for other functions called in this function\ntranslate to wat and inline to a string\nwrap string in a function declaration\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.restructure-Tuple{Integer,Array,Any}","page":"Internals","title":"WebAssemblyText.restructure","text":"restructure(items)\n\nRestructure items for more straightforward translation.\n\nDetails:\n\nexpand n-ary representation ([mul,a,b,c,d] => [mul,d,[mul,c,[mul,a,b]]])\ninsert implied iterator increment ([:,1,4] => [:,1,1,4])\npick only initial iterator value if :(iterate) has a single arg [:(iterate),target] => ssa[target][1]\nspecify :(iteratef) instead of :(iterate) for float iteration.\nput ifelse condition in last arg instead of first [ifselse, cond, a, b] => [select, a, b, cond]\n\nTODO:\n\nexpand chains of comparisons [comparison, 1, <, i, <=, n] => [&&,[<,1,i],[<=,i,n]]\n.wat dont have Bool or Nothing types so iterating across zero does NOT work.. figure out a way to solve this\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.stringify-Tuple{Array}","page":"Internals","title":"WebAssemblyText.stringify","text":"inline(ssa::Array)\n\nGet a wat single string from a an already translated ssa.\n\nDetails:\n\nGet a list of ssa references\nAdd parenthesis\nReplace refs by the referenced lines\nDelete the referenced lines\nadd block and loop control flow based on GotoNodes\nJoin.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.structure-Tuple{Any}","page":"Internals","title":"WebAssemblyText.structure","text":"structure(item::Expr)\n\nExpression as a vector: [head, args...]\n\nDetals:\n\nThere are two expression flavors:\n\nhead in args[1]\nhead in head\n\nmake them be represented the same way\n\neval refs of constants\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.translate-Tuple{Integer,Core.CodeInfo,Any}","page":"Internals","title":"WebAssemblyText.translate","text":"translate(i::Integer, cinfo::CodeInfo, item)\n\nGet a wat string from item, specialized on item type.\n\n\n\n\n\n","category":"method"},{"location":"Internals/#WebAssemblyText.translate-Tuple{Integer,Core.CodeInfo,Array}","page":"Internals","title":"WebAssemblyText.translate","text":"translate(ci::CodeInfo, items::Array)\n\nGet a wat string from items, branching to special cases based on items[1].\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Work in progress!\nThis documentation (and the entire package) is a work in progress.","category":"page"},{"location":"#Public-functions","page":"Home","title":"Public functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"jl2wat\njlstring2wat","category":"page"},{"location":"#WebAssemblyText.jl2wat","page":"Home","title":"WebAssemblyText.jl2wat","text":"jl2wat(path::AbstractString)\n\nConvert contents of a julia source code file to WebAssembly text.\n\nExamples\n\njulia> using WebAssemblyText\njulia> wat = jl2wat(\"example.jl\")\njulia> println(wat)\n\n\n\n\n\n","category":"function"},{"location":"#WebAssemblyText.jlstring2wat","page":"Home","title":"WebAssemblyText.jlstring2wat","text":"jlstring2wat(str::AbstractString)\n\nConvert a string of julia source code to WebAssembly text.\n\nExamples\n\njulia> using WebAssemblyText\njulia> str=\"\nhello(x) = 2.0*x\nhello(1.0)\n\";\njulia> wat = jlstring2wat(str);\njulia> println(wat)\n\n(module \n\n(func $hello (export \"hello\") (param $x f32) (result f32)\n( return ( f32.mul (f32.const 2.0) (local.get $x) ) ))\n)\n\n\n\n\n\n","category":"function"}]
}
